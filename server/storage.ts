// server/storage.ts
import { drizzle } from "drizzle-orm/node-postgres";
import pg from "pg";
const { Pool } = pg;
import { eq } from "drizzle-orm";
import {
  users,
  documents,
  reminders,
  type User, // User type now has UUID id
  type InsertUser, // InsertUser schema is updated
  type Document, // Document type now has UUID userId
  type InsertDocument, // InsertDocument schema expects UUID userId
  type Reminder, // Reminder type now has UUID userId
  type InsertReminder, // InsertReminder schema expects UUID userId
} from "@shared/schema";

// Ensure SUPABASE_DB_URL is set
if (!process.env.SUPABASE_DB_URL) {
  throw new Error("SUPABASE_DB_URL is not set in environment variables");
}

// Initialize PostgreSQL pool
const pool = new Pool({
  connectionString: process.env.SUPABASE_DB_URL,
});

// Initialize Drizzle ORM
const db = drizzle(pool);

// Update interface to use string for user IDs (UUIDs)
export interface IStorage {
  // User ID is now a string (UUID)
  getUser(id: string): Promise<User | undefined>; // getUserByUsername might be less used if using email auth, but keep for now
  getUserByUsername(username: string): Promise<User | undefined>; // createUser might only insert profile data, linked by the UUID from Supabase Auth
  createUser(user: InsertUser & { id: string }): Promise<User>; // Expect id (UUID) from auth
  getDocument(id: number): Promise<Document | undefined>; // getDocumentsByUserId now takes string (UUID) userId
  getDocumentsByUserId(userId: string): Promise<Document[]>; // createDocument now expects InsertDocument which includes string (UUID) userId
  createDocument(document: InsertDocument): Promise<Document>;
  updateDocumentAnalysis(
    id: number,
    data: {
      summary?: string;
      actionItems?: any[];
      tags?: string[];
      status?: string;
    }
  ): Promise<Document | undefined>;
  getReminder(id: number): Promise<Reminder | undefined>; // getRemindersByUserId now takes string (UUID) userId
  getRemindersByUserId(userId: string): Promise<Reminder[]>; // createReminder now expects InsertReminder which includes string (UUID) userId
  createReminder(reminder: InsertReminder): Promise<Reminder>;
  updateReminder(
    id: number,
    data: Partial<Reminder>
  ): Promise<Reminder | undefined>;
}

export class SupabaseStorage implements IStorage {
  // Accept string (UUID) id
  async getUser(id: string): Promise<User | undefined> {
    const result = await db
      .select()
      .from(users)
      .where(eq(users.id, id))
      .limit(1);
    return result[0];
  } // Keep as is, username is still a string

  async getUserByUsername(username: string): Promise<User | undefined> {
    const result = await db
      .select()
      .from(users)
      .where(eq(users.username, username))
      .limit(1);
    return result[0];
  } // createUser now accepts the UUID generated by Supabase Auth

  async createUser(insertUser: InsertUser & { id: string }): Promise<User> {
    // Insert into our 'users' table using the UUID from Supabase Auth
    const result = await db.insert(users).values(insertUser).returning();
    return result[0];
  } // Keep as is, document ID is still an integer

  async getDocument(id: number): Promise<Document | undefined> {
    const result = await db
      .select()
      .from(documents)
      .where(eq(documents.id, id))
      .limit(1);
    return result[0];
  } // Accept string (UUID) userId

  async getDocumentsByUserId(userId: string): Promise<Document[]> {
    // Query using the UUID
    return db.select().from(documents).where(eq(documents.userId, userId));
  } // Accept InsertDocument which contains string (UUID) userId

  async createDocument(documentData: InsertDocument): Promise<Document> {
    const result = await db
      .insert(documents)
      .values({
        ...documentData,
        uploadedAt: new Date(), // Ensure date is set if not in InsertDocument
      })
      .returning();
    return result[0];
  } // Keep as is, document ID is integer

  async updateDocumentAnalysis(
    id: number,
    data: {
      summary?: string;
      actionItems?: any[];
      tags?: string[];
      status?: string;
    }
  ): Promise<Document | undefined> {
    const updates: Partial<Document> = {};
    if (data.summary !== undefined) updates.summary = data.summary;
    if (data.actionItems !== undefined) updates.actionItems = data.actionItems;
    if (data.tags !== undefined) updates.tags = data.tags;
    if (data.status !== undefined) updates.status = data.status;

    const result = await db
      .update(documents)
      .set(updates)
      .where(eq(documents.id, id))
      .returning();
    return result[0];
  } // Keep as is, reminder ID is integer

  async getReminder(id: number): Promise<Reminder | undefined> {
    const result = await db
      .select()
      .from(reminders)
      .where(eq(reminders.id, id))
      .limit(1);
    return result[0];
  } // Accept string (UUID) userId

  async getRemindersByUserId(userId: string): Promise<Reminder[]> {
    // Query using the UUID
    return db.select().from(reminders).where(eq(reminders.userId, userId));
  } // Accept InsertReminder which contains string (UUID) userId

  async createReminder(reminderData: InsertReminder): Promise<Reminder> {
    const result = await db.insert(reminders).values(reminderData).returning();
    return result[0];
  } // Keep as is, reminder ID is integer

  async updateReminder(
    id: number,
    data: Partial<Reminder>
  ): Promise<Reminder | undefined> {
    const result = await db
      .update(reminders)
      .set(data)
      .where(eq(reminders.id, id))
      .returning();
    return result[0];
  }
}

export const storage = new SupabaseStorage();

// Cleanup pool on process exit
process.on("SIGINT", async () => {
  console.log("Shutting down database pool...");
  await pool.end();
  console.log("Database pool shut down.");
  process.exit(0);
});

// Handle uncaught exceptions as well
process.on("uncaughtException", async (err) => {
  console.error("Uncaught Exception:", err);
  console.log("Shutting down database pool due to uncaught exception...");
  await pool.end();
  console.log("Database pool shut down.");
  process.exit(1);
});

process.on("unhandledRejection", async (reason, promise) => {
  console.error("Unhandled Rejection at:", promise, "reason:", reason);
  console.log("Shutting down database pool due to unhandled rejection...");
  await pool.end();
  console.log("Database pool shut down.");
  process.exit(1);
});
